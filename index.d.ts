/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum Axis {
  X = 0,
  Y = 1,
  Z = 2
}
export interface HitResult {
  distance: number
  position: Vector3f
}
export declare class Vector3f {
  x: number
  y: number
  z: number
  constructor(x: number, y: number, z: number)
  dot(other: Vector3f): number
  length(): number
  squareLength(): number
  normalize(): Vector3f
  lerp(other: Vector3f, t: number): Vector3f
  add(other: Vector3f): Vector3f
  subtract(other: Vector3f): Vector3f
  multiply(scalar: number): Vector3f
  cross(other: Vector3f): Vector3f
  absolute(): Vector3f
  distance(other: Vector3f): number
  floor(): Vector3f
  round(): Vector3f
  ceil(): Vector3f
  slerp(other: Vector3f, t: number): Vector3f
  equals(other: Vector3f): boolean
  axis(axis: Axis): number
}
/**
 * Represents an Axis-Aligned Bounding Box (AABB) in 3D space.
 * An AABB is defined by its minimum and maximum corners.
*/
export declare class AABB {
  min: Vector3f
  max: Vector3f
  /**
  * Constructs an AABB with specified minimum and maximum corners.
  *
  * @param min - The minimum corner of the AABB (Vector3f).
  * @param max - The maximum corner of the AABB (Vector3f).
  */
  constructor(min: Vector3f, max: Vector3f)
  /**
  * Moves the AABB by a given position vector.
  *
  * @param position - The vector to move the AABB by (Vector3f).
  * @return A new AABB moved by the position vector.
  */
  translate(v: Vector3f): AABB
  /**
  * Expands the AABB by a given vector. The expansion affects the min and max points
  * depending on whether the expansion vector is positive or negative.
  *
  * @param position - The expansion vector (Vector3f).
  * @return A new AABB expanded by the position vector.
  */
  expand(v: Vector3f): AABB
  /**
  * Checks if a given point is inside the AABB.
  *
  * @param position - The point to check (Vector3f).
  * @return True if the point is inside the AABB; otherwise, false.
  */
  contains(v: Vector3f): boolean
  within(v: Vector3f): boolean
  grow(growScale: number): AABB
  intersects(aabb: AABB): boolean
  /**
  * Determines if a given value intersects a line segment defined by two vectors
  * along a specified axis, and returns the intersection point if it falls within
  * the segment bounds.
  *
  * @param axis - The axis along which to check the intersection (Axis).
  * @param vecA - The start of the line segment (Vector3f).
  * @param vecB - The end of the line segment (Vector3f).
  * @param value - The value to check for intersection.
  * @return The intersection point as a Vector3f if it is valid; otherwise, undefined.
  */
  static onLine(axis: Axis, vecA: Vector3f, vecB: Vector3f, value: number): Vector3f | null
  /**
  * Checks if a given vector is within the AABB bounds along specified axes.
  *
  * @param axis - An array of axes to check against (Array<Axis>).
  * @param vec - The vector to check (Vector3f).
  * @return True if the vector is within the bounds on the specified axes; otherwise, false.
  */
  withinAxis(axis: Array<Axis>, vector: Vector3f): boolean
  /**
  * Determines if a ray defined by a start and end vector intersects with the AABB.
  * Returns the hit result with the intersection details.
  *
  * @param aabb - The AABB to check for intersection (AABB).
  * @param start - The start point of the ray (Vector3f).
  * @param end - The end point of the ray (Vector3f).
  * @return A HitResult if an intersection is found; otherwise, undefined.
  */
  static Intercept(aabb: AABB, start: Vector3f, end: Vector3f): HitResult | null
}
export declare class Raycaster {
  /**
  * Traverses blocks along a line segment defined by start and end vectors.
  * Applies a given condition function to each block and stops if the condition is met.
  *
  * @param start - The starting point of the line segment (Vector3f).
  * @param end - The ending point of the line segment (Vector3f).
  * @param condition - A function that takes BlockCoordinates and returns a boolean,
  *                    defining the condition to stop traversing when met.
  */
  static transverseBlocks(start: Vector3f, end: Vector3f, condition: (position: Vector3f) => bool): void
  /**
  * Returns a Vector3f containing the sign of each component of the given vector.
  *
  * @param vec - The vector to get the sign from.
  * @return A new Vector3f with the sign of each component.
  */
  static sign(vector: Vector3f): Vector3f
  static stepSize(step: Vector3f, direction: Vector3f): Vector3f
  /**
  * Calculates the distance from the given number to the next lower integer (boundary).
  *
  * @param number - The number to calculate the boundary for.
  * @return The distance from the number to the nearest lower integer.
  */
  static boundary(n: number): number
}
